---
title: 'Python Tooling in 2025'
description: 'I bought a Framework 13 about one year ago. Heres my thoughts'
date: 2026-01-11
tags: ['thoughts']
image: './w.jpg'
authors: ['airwu']
---

# context
I had a brief conversation with a friend about successful open source projects. During the discussion, he brought
up astral.sh, which is a company known for its popular open source python tooling that is pairs nicely with their paid services. 

This conversation made me curious about the current state of python tooling, as I had never really explored this space before.
In fact, almost every single python project I have ever made, followed the "old" way of doing things.

# older python tooling
Firstly, here's how I would start a Python project:
```sh
# 1. Create the environment
python -m venv venv

# 2. Activate the environment
source venv/bin/activate

# 3. Upgrade pip, install dependencies
pip install --upgrade pip
pip install pandas requests

# 4. Freeze your dependencies or install using a requirements.txt in the first place
pip freeze > requirements.txt

# 5. Develop your project
```
Pip, venv, and setuptools are my bread and butter. Usually, I'm just installing pre-built wheels (.whl) from PyPI (the default repository for pip) via pip.      
I'd do this in a virtual environment in order to avoid polluting my global python environment and entering dependency hell. 

If I were to install something from source, pip would refer to the `pyproject.toml` to determine how to build the package and install it. 
> Note: Or if I were working with an old version of pip (< version 19), it would simply call setup.py to build locally.

Now, maybe my ignorance is showing, but I found this approach to be compeletely fine. 
It does feel a bit too imperative, so I usually omit the whole python virtual environment and make use of Docker containers in combination with a `requirements.txt` for some "declarative" project management. 
It works fine for me, but apparently, this isnt the solution. A quick search on the internet shows that tools like Poetry or direnv could help.

# modern python package managers
I'll be focusing on poetry and uv, as they are the most popular python package managers.

### Poetry
Poetry basically just abstracts away the workflow I described above. This four step process of:

1. Create venv 
2. pip install packages 
3. Manually save them to requirements.txt 
4. Create a setup.py 

becomes simply `poetry add <package>`. If you have a virtual environment in the project, it will use it automatically. If not, it will automatically create one in a special cache location. 
By running `poetry run python script.py`, it will automatically enter that virtual environment. 
Dependencies are specificied in a section in the `pyproject.toml` file (kind of like how we used `requirements.txt`), and the specific versions are hashed in a `poetry.lock` file for deterministic builds. 

So the key features are deterministic builds, better dependency management, automatic virtual environments, and a simpler way to build/publish packages. All this while maintaining an easier user experience.

```sh
# This reads pyproject.toml & poetry.lock to install dependencies, then creates venv
poetry install

# "poetry run" automatically hooks into the correct venv
poetry run python script.py
```

### uv
So if Poetry already solves so many problems, is there that much to improve upon?
Well, apparently uv is the "next generation" python package manager written in Rust, focusing on speed and centralizing different python tooling for an even easier UX.

```sh
# uv sees you are missing dependencies, installs them, creates the venv, and runs the code.
uv run script.py
```

By increasing the scope of the tooling, uv can do more than pacakage management, it also helps with project management.
There's plenty of little features that improve the ux like writing dependencies directly into the script files and just having someone else simply run that script (and have uv set up the environment for you, including installing the correct version of python).

### speed difference
Now, uv is written in Rust and poetry is written in Python. In addition to being slower due to the langauge difference, poetry is also basically a wrapper around pip, venv, and setuptools. Despite everything pointing to uv being faster, I wanted to test it anyways.

So we'll install the following pacakges:
1. pandas
2. numpy
3. scipy
4. fastapi

Then, we'll create a blank project and use `time` to measure how long it takes.

```sh collapse={4-35}
~/test/poetry-bench ❯ poetry init -n

~/test/poetry-bench | Python v3.12.3 ❯ time poetry add pandas numpy scipy fastapi
Creating virtualenv poetry-bench-vLHsZiHZ-py3.12 in /home/air/.cache/pypoetry/virtualenvs
Using version ^2.3.3 for pandas
Using version ^2.4.1 for numpy
Using version ^1.17.0 for scipy
Using version ^0.128.0 for fastapi

Updating dependencies
Resolving dependencies... (1.7s)

Package operations: 17 installs, 0 updates, 0 removals

  - Installing idna (3.11)
  - Installing typing-extensions (4.15.0)
  - Installing annotated-types (0.7.0)
  - Installing anyio (4.12.1)
  - Installing pydantic-core (2.41.5)
  - Installing six (1.17.0)
  - Installing typing-inspection (0.4.2)
  - Installing numpy (2.4.1): Pending...
  - Installing annotated-doc (0.0.4)
  - Installing numpy (2.4.1): Pending...
  - Installing numpy (2.4.1)
  - Installing pydantic (2.12.5)
  - Installing python-dateutil (2.9.0.post0)
  - Installing pytz (2025.2)
  - Installing starlette (0.50.0)
  - Installing tzdata (2025.3)
  - Installing fastapi (0.128.0)
  - Installing pandas (2.3.3)
  - Installing scipy (1.17.0)

Writing lock file

real    0m11.372s
user    0m6.490s
sys     0m5.341s
```
As you can see, poetry takes around 11 seconds, and it also entered the virtual envrionment for us (as shown by my terminal prompt). 

Now, for uv:
```sh collapse={5-26}
~/test/uv-bench ❯ uv init
Initialized project `uv-bench`

~/test/uv-bench ❯ time uv add pandas numpy scipy fastapi
Using CPython 3.12.3 interpreter at: /usr/bin/python3.12
Creating virtual environment at: .venv
Resolved 18 packages in 1.65s
Prepared 17 packages in 2.04s
Installed 17 packages in 209ms
 + annotated-doc==0.0.4
 + annotated-types==0.7.0
 + anyio==4.12.1
 + fastapi==0.128.0
 + idna==3.11
 + numpy==2.4.1
 + pandas==2.3.3
 + pydantic==2.12.5
 + pydantic-core==2.41.5
 + python-dateutil==2.9.0.post0
 + pytz==2025.2
 + scipy==1.17.0
 + six==1.17.0
 + starlette==0.50.0
 + typing-extensions==4.15.0
 + typing-inspection==0.4.2
 + tzdata==2025.3

real    0m4.077s
user    0m1.671s
sys     0m2.892s
```

As we can see, uv is almost 3 times faster than poetry.

# modern code linter and formatters
Since we're exploring modern python tooling, we should also look at linters. While there are many options and tools like Flake8, Pylint, and Black, astral.sh's Ruff once again aims to unify tools and improve speed.